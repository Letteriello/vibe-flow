/**
 * QA Report Markdown Template
 * Feature: FEAT-003 - Gera√ß√£o Automatizada de qa-report.md
 */

import type { QAReport, VerificationResult, QASummary, Verdict } from './types';

/**
 * Badge emojis for status display
 */
const STATUS_BADGES: Record<string, string> = {
  PASS: '‚úÖ',
  FAIL: '‚ùå',
  WARNING: '‚ö†Ô∏è',
  SKIPPED: '‚è≠Ô∏è',
};

/**
 * Badge emojis for verdict display
 */
const VERDICT_BADGES: Record<Verdict, string> = {
  PASS: '‚úÖ APROVADO',
  WARNING: '‚ö†Ô∏è APROVADO COM RESSALVAS',
  FAIL: '‚ùå REPROVADO',
};

/**
 * Format a timestamp to readable date
 */
function formatTimestamp(isoString: string): string {
  const date = new Date(isoString);
  return date.toLocaleString('pt-BR', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  });
}

/**
 * Format duration in milliseconds to human readable
 */
function formatDuration(ms: number): string {
  if (ms < 1000) {
    return `${ms}ms`;
  }
  const seconds = Math.floor(ms / 1000);
  if (seconds < 60) {
    return `${seconds}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds}s`;
}

/**
 * Generate verification details table row
 */
function formatVerificationRow(result: VerificationResult): string {
  const badge = STATUS_BADGES[result.status] || '‚ùì';
  const duration = formatDuration(result.duration);
  const exitInfo = result.exitCode !== undefined ? `[exit: ${result.exitCode}]` : '';

  let row = `| ${badge} ${result.name} | ${result.status} | ${duration} | ${exitInfo} |`;

  if (result.issues && result.issues.length > 0) {
    row += `\n|   | **Issues:** | ${result.issues.length} found | ${result.issues.slice(0, 3).join(', ')}... |`;
  }

  return row;
}

/**
 * Generate summary section
 */
function formatSummary(summary: QASummary): string {
  const percentage = summary.total > 0
    ? Math.round((summary.passed / summary.total) * 100)
    : 0;

  return `
## üìä Resumo

| M√©trica | Valor |
|---------|-------|
| Total | ${summary.total} |
| ‚úÖ Passou | ${summary.passed} |
| ‚ùå Falhou | ${summary.failed} |
| ‚ö†Ô∏è Warnings | ${summary.warnings} |
| ‚è≠Ô∏è Bloqueado | ${summary.blocked} |
| **Taxa de Sucesso** | **${percentage}%** |
`;
}

/**
 * Generate recommendations section
 */
function formatRecommendations(recommendations: string[]): string {
  if (!recommendations || recommendations.length === 0) {
    return '';
  }

  const items = recommendations.map((rec, i) => `${i + 1}. ${rec}`).join('\n');
  return `
## üí° Recomenda√ß√µes

${items}
`;
}

/**
 * Generate verification details section
 */
function formatVerifications(verifications: VerificationResult[]): string {
  const rows = verifications.map(formatVerificationRow).join('\n');

  return `
## üîç Verifica√ß√µes

| Verifica√ß√£o | Status | Dura√ß√£o | Info |
|-------------|--------|----------|------|
${rows}
`;
}

/**
 * Generate header section
 */
function formatHeader(report: QAReport): string {
  const verdictBadge = VERDICT_BADGES[report.verdict];

  return `# QA Report - ${report.projectPath}

**ID:** ${report.id}
**Data:** ${formatTimestamp(report.timestamp)}
**Pipeline:** ${report.pipeline || 'N/A'}
**Veredicto:** ${verdictBadge}

---
`;
}

/**
 * Generate full QA report in Markdown format
 */
export function generateMarkdownReport(report: QAReport): string {
  const sections: string[] = [];

  // Header
  sections.push(formatHeader(report));

  // Summary
  sections.push(formatSummary(report.summary));

  // Verifications
  sections.push(formatVerifications(report.verifications));

  // Recommendations
  if (report.recommendations && report.recommendations.length > 0) {
    sections.push(formatRecommendations(report.recommendations));
  }

  // Footer
  sections.push(`
---
*Generated by vibe-flow QA Report Generator*
`);

  return sections.join('\n');
}

/**
 * Generate a minimal summary line (for CLI output)
 */
export function formatSummaryLine(report: QAReport): string {
  const { passed, failed, warnings, total } = report.summary;
  const badge = VERDICT_BADGES[report.verdict];
  return `${badge} [${passed}/${total} passed, ${failed} failed, ${warnings} warnings]`;
}
