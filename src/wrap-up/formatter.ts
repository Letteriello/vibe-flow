/**
 * FastMarkdownFormatter - Optimized markdown report generator
 * Uses array buffer pattern for high-performance document assembly
 */
export interface SessionData {
  projectName?: string;
  phase?: string;
  currentStep?: number;
  totalSteps?: number;
  decisions?: Array<{ phase: string; description: string }>;
  errors?: Array<{ phase: string; message: string }>;
  filesModified?: string[];
  commits?: number;
  patternsDetected?: number;
  rulesGenerated?: number;
  startTime?: string;
  endTime?: string;
  duration?: number;
}

export class FastMarkdownFormatter {
  /**
   * Generates a complete audit report from session data
   * Uses array buffer pattern for O(n) string assembly
   */
  generateReport(sessionData: SessionData): string {
    const sections: string[] = [];

    // Header
    sections.push(
      this.buildHeader(sessionData)
    );

    // Project State
    sections.push(
      this.buildProjectState(sessionData)
    );

    // Execution Summary
    sections.push(
      this.buildExecutionSummary(sessionData)
    );

    // Decisions
    sections.push(
      this.buildDecisions(sessionData)
    );

    // Errors
    sections.push(
      this.buildErrors(sessionData)
    );

    // Files Modified
    sections.push(
      this.buildFilesModified(sessionData)
    );

    // Footer
    sections.push(
      this.buildFooter(sessionData)
    );

    return sections.join('\n');
  }

  private buildHeader(data: SessionData): string {
    const timestamp = data.endTime || new Date().toISOString();
    return `# Session Audit Report

Generated: ${timestamp}

---
`;
  }

  private buildProjectState(data: SessionData): string {
    const lines: string[] = [
      '## Project State',
      '',
      `| Property | Value |`,
      `|----------|-------|`,
    ];

    if (data.projectName) {
      lines.push(`| **Project** | ${data.projectName} |`);
    }
    if (data.phase) {
      lines.push(`| **Phase** | ${data.phase} |`);
    }
    if (data.currentStep !== undefined && data.totalSteps !== undefined) {
      lines.push(`| **Progress** | Step ${data.currentStep} / ${data.totalSteps} |`);
    }
    if (data.duration !== undefined) {
      lines.push(`| **Duration** | ${this.formatDuration(data.duration)} |`);
    }

    lines.push('');
    return lines.join('\n');
  }

  private buildExecutionSummary(data: SessionData): string {
    const summaryItems: string[] = [];

    if (data.commits !== undefined) {
      summaryItems.push(`- **Commits:** ${data.commits}`);
    }
    if (data.patternsDetected !== undefined) {
      summaryItems.push(`- **Patterns Detected:** ${data.patternsDetected}`);
    }
    if (data.rulesGenerated !== undefined) {
      summaryItems.push(`- **Rules Generated:** ${data.rulesGenerated}`);
    }

    if (summaryItems.length === 0) {
      return '';
    }

    return [
      '## Execution Summary',
      '',
      ...summaryItems,
      ''
    ].join('\n');
  }

  private buildDecisions(data: SessionData): string {
    const decisions = data.decisions;

    if (!decisions || decisions.length === 0) {
      return [
        '## Decisions Made',
        '',
        '_No decisions recorded_',
        ''
      ].join('\n');
    }

    const lines: string[] = [
      '## Decisions Made',
      ''
    ];

    for (const decision of decisions) {
      lines.push(`- **[${decision.phase}]** ${decision.description}`);
    }

    lines.push('');
    return lines.join('\n');
  }

  private buildErrors(data: SessionData): string {
    const errors = data.errors;

    if (!errors || errors.length === 0) {
      return [
        '## Errors',
        '',
        '_No errors recorded_',
        ''
      ].join('\n');
    }

    const lines: string[] = [
      '## Errors',
      ''
    ];

    for (const error of errors) {
      lines.push(`- **[${error.phase}]** ${error.message}`);
    }

    lines.push('');
    return lines.join('\n');
  }

  private buildFilesModified(data: SessionData): string {
    const files = data.filesModified;

    if (!files || files.length === 0) {
      return '';
    }

    const lines: string[] = [
      '## Files Modified',
      ''
    ];

    // Use map for efficient transformation
    const fileList = files.map(f => `- \`${f}\``);

    return lines.concat(fileList, ['']).join('\n');
  }

  private buildFooter(data: SessionData): string {
    return [
      '---',
      '',
      '*Report generated by vibe-flow wrap-up*',
      ''
    ].join('\n');
  }

  private formatDuration(ms: number): string {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;

    if (minutes > 0) {
      return `${minutes}m ${remainingSeconds}s`;
    }
    return `${seconds}s`;
  }
}
