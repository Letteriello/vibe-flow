// Audit Logger Module - Session transaction tracking and reporting
import { promises as fs } from 'fs';
import { join } from 'path';
import { homedir } from 'os';

export interface AuditEntry {
  timestamp: string;
  type: 'decision' | 'error_resolved' | 'file_touched' | 'state_change';
  reasoning?: string;
  action?: string;
  file?: string;
  error?: string;
  fromState?: string;
  toState?: string;
}

export interface AuditReport {
  sessionId: string;
  startTime: string;
  endTime: string;
  entries: AuditEntry[];
  summary: {
    decisions: number;
    errorsResolved: number;
    filesTouched: number;
    stateChanges: number;
  };
}

export class SessionAuditLogger {
  private sessionId: string;
  private startTime: string;
  private entries: AuditEntry[] = [];
  private auditDir: string;

  constructor(sessionId?: string, projectPath?: string) {
    this.sessionId = sessionId || this.generateSessionId();
    this.startTime = new Date().toISOString();
    const basePath = projectPath || process.cwd();
    this.auditDir = join(basePath, '.vibe-flow', 'audit');
  }

  private generateSessionId(): string {
    const now = new Date();
    const timestamp = now.toISOString()
      .replace(/[:.]/g, '-')
      .replace('T', '_')
      .slice(0, 19);
    return `session-${timestamp}`;
  }

  logDecision(reasoning: string, action: string): void {
    const entry: AuditEntry = {
      timestamp: new Date().toISOString(),
      type: 'decision',
      reasoning,
      action
    };
    this.entries.push(entry);
  }

  logErrorResolved(error: string, resolution: string): void {
    const entry: AuditEntry = {
      timestamp: new Date().toISOString(),
      type: 'error_resolved',
      reasoning: resolution,
      error
    };
    this.entries.push(entry);
  }

  logFileTouched(filePath: string, operation: 'created' | 'modified' | 'deleted'): void {
    const entry: AuditEntry = {
      timestamp: new Date().toISOString(),
      type: 'file_touched',
      action: operation,
      file: filePath
    };
    this.entries.push(entry);
  }

  logStateChange(fromState: string, toState: string, reason?: string): void {
    const entry: AuditEntry = {
      timestamp: new Date().toISOString(),
      type: 'state_change',
      fromState,
      toState,
      reasoning: reason
    };
    this.entries.push(entry);
  }

  generateMarkdownReport(): string {
    const endTime = new Date().toISOString();
    const summary = this.calculateSummary();

    let markdown = `# Session Audit Report

**Session ID:** ${this.sessionId}
**Start Time:** ${this.startTime}
**End Time:** ${endTime}

---

## Summary

| Metric | Count |
|--------|-------|
| Decisions | ${summary.decisions} |
| Errors Resolved | ${summary.errorsResolved} |
| Files Touched | ${summary.filesTouched} |
| State Changes | ${summary.stateChanges} |
| **Total Entries** | ${this.entries.length} |

---

## Transaction Log

`;

    if (this.entries.length === 0) {
      markdown += '*No transactions recorded during this session.*\n';
    } else {
      // Group entries by type
      const decisions = this.entries.filter(e => e.type === 'decision');
      const errors = this.entries.filter(e => e.type === 'error_resolved');
      const files = this.entries.filter(e => e.type === 'file_touched');
      const states = this.entries.filter(e => e.type === 'state_change');

      if (decisions.length > 0) {
        markdown += `### Decisions\n\n`;
        for (const entry of decisions) {
          markdown += `- **${entry.timestamp}**\n`;
          markdown += `  - Reasoning: ${entry.reasoning}\n`;
          markdown += `  - Action: ${entry.action}\n\n`;
        }
      }

      if (errors.length > 0) {
        markdown += `### Errors Resolved\n\n`;
        for (const entry of errors) {
          markdown += `- **${entry.timestamp}**\n`;
          markdown += `  - Error: ${entry.error}\n`;
          markdown += `  - Resolution: ${entry.reasoning}\n\n`;
        }
      }

      if (files.length > 0) {
        markdown += `### Files Touched\n\n`;
        for (const entry of files) {
          markdown += `- **${entry.timestamp}**\n`;
          markdown += `  - File: \`${entry.file}\`\n`;
          markdown += `  - Operation: ${entry.action}\n\n`;
        }
      }

      if (states.length > 0) {
        markdown += `### State Changes\n\n`;
        for (const entry of states) {
          markdown += `- **${entry.timestamp}**\n`;
          markdown += `  - From: \`${entry.fromState}\` â†’ To: \`${entry.toState}\`\n`;
          if (entry.reasoning) {
            markdown += `  - Reason: ${entry.reasoning}\n`;
          }
          markdown += '\n';
        }
      }
    }

    markdown += `---

*Report generated by vibe-flow audit logger*
`;

    return markdown;
  }

  private calculateSummary(): AuditReport['summary'] {
    return {
      decisions: this.entries.filter(e => e.type === 'decision').length,
      errorsResolved: this.entries.filter(e => e.type === 'error_resolved').length,
      filesTouched: this.entries.filter(e => e.type === 'file_touched').length,
      stateChanges: this.entries.filter(e => e.type === 'state_change').length
    };
  }

  async saveReport(): Promise<string> {
    await fs.mkdir(this.auditDir, { recursive: true });

    const reportPath = join(this.auditDir, `${this.sessionId}.md`);
    const markdown = this.generateMarkdownReport();

    await fs.writeFile(reportPath, markdown, 'utf-8');
    return reportPath;
  }

  getEntries(): AuditEntry[] {
    return [...this.entries];
  }

  getSessionId(): string {
    return this.sessionId;
  }

  getStartTime(): string {
    return this.startTime;
  }

  getAuditDir(): string {
    return this.auditDir;
  }
}
